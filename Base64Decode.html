<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml" class="h-full leading-none">
<head>
	<meta charset="utf-8" />
	<title>Décodage Base64</title>
	<link rel="shortcut icon" type="image/png" href="favicon.png"/>
	<script src="https://cdn.sheetjs.com/xlsx-0.20.0/package/dist/xlsx.full.min.js"></script>
	<script src="https://cdn.tailwindcss.com"></script>
	<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
	<script>
		tailwind.config = {
			theme: {
				extend: {
					colors: {
						tomato: '#e74c3c',
					}
				}
			}
		}
	</script>
	<style>
		#excel-preview table {
			border-collapse: collapse;
			margin-top: 1rem;
			font-family: sans-serif;
		}
		#excel-preview td, #excel-preview th {
			border: 1px solid #ccc;
			padding: 4px 8px;
			font-size: 0.7rem;
			line-height: 0.99rem;
		}
		#excel-preview .bold { font-weight: bold; }
		#excel-preview .italic { font-style: italic; }
		#excel-preview .align-left { text-align: left; }
		#excel-preview .align-center { text-align: center; }
		#excel-preview .align-right { text-align: right; }		
	</style>
</head>
<body class="h-full flex flex-col flex-nowrap p-1">
	<header class="grow-0 flex flex-row space-x-3 ">
		<h1 class="text-lg">Chargement contenu en Base64</h1>
		<button id="run" class="appearance-none border-none flex items-center justify-center px-4 py-2 bg-tomato text-white rounded hover:bg-red-600 transition text-sm"><span class="leading-none">Run</span></button>
	</header>
	<header class="grow-0 flex flex-row py-1 space-x-3 items-baseline">
		<label for="bulletin"><span>Base64 : </span></label>
		<input class="border-2 flex-grow" id="base64input" type="input"/>
	</header>
	<main class="grow flex flex-row flex-nowrap justify-between">
		<object style="display: none;" class="w-full h-full border-2" id="pdf-preview" type="application/pdf"></object>
		<div style="display: none;" id="text-preview" class="max-w-full overflow-x-auto border-2">
			<pre id="text-content" class="whitespace-pre font-mono text-sm"></pre>
		</div>
		<div style="display: none;" id="excel-preview" class="max-w-full overflow-x-auto border-2">
		</div>
	</main>
	<script type="module">
		function isBase64PDF(base64String) {
			return base64String.substring(0, 4) === 'JVBER';
		}
		function isBase64Excel(base64String) {
			console.log('isBase64Excel', base64String.substring(0, 5), base64String.substring(0, 5) === 'PD94b');
			return base64String.substring(0, 5) === 'PD94b';
		}
		function base64ToText(base64String) {
			// Étape 1 : décoder Base64 vers une chaîne binaire (ASCII)
			const binaryString = atob(base64String);
			// Étape 2 : convertir la chaîne binaire en tableau d’octets
			const byteArray = Uint8Array.from(binaryString, char => char.charCodeAt(0));
			// Étape 3 : décoder les octets en texte UTF-8
			const decoder = new TextDecoder('utf-8');
			return decoder.decode(byteArray);
		}
		function excelToHTML(base64) {
			const parser = new DOMParser();
			const xmlDoc = parser.parseFromString(base64ToText(base64), "text/xml");

			// Parse styles (comme avant)
			const styleMap = {};
			const styles = xmlDoc.querySelectorAll("Style");
			styles.forEach(style => {
				const id = style.getAttribute("ss:ID");
				const font = style.querySelector("Font");
				const alignment = style.querySelector("Alignment");
				const interior = style.querySelector("Interior");

				const styleProps = { classList: [], style: [] };
				if (font) {
				if (font.getAttribute("ss:Bold") === "1") styleProps.classList.push("bold");
				if (font.getAttribute("ss:Italic") === "1") styleProps.classList.push("italic");
				if (font.getAttribute("ss:Color")) styleProps.style.push(`color: ${font.getAttribute("ss:Color")}`);
				}
				if (alignment) {
				const horiz = alignment.getAttribute("ss:Horizontal");
				if (horiz) styleProps.classList.push("align-" + horiz.toLowerCase());
				}
				if (interior && interior.getAttribute("ss:Color")) {
				styleProps.style.push(`background-color: ${interior.getAttribute("ss:Color")}`);
				}
				styleMap[id] = styleProps;
			});

			const worksheet = xmlDoc.querySelector("Worksheet");
			const rows = Array.from(worksheet.querySelectorAll("Table > Row"));

			// Structure pour mémoriser quelles cellules sauter (pour fusion verticale)
			// Clé = "rowIndex,colIndex"
			const skipCells = new Set();

			let html = "<table><tbody>";

			rows.forEach((row, rowIndex) => {
				html += "<tr>";
				const cells = Array.from(row.querySelectorAll("Cell"));
				let colIndex = 0;

				for (let i = 0; i < cells.length; i++) {
					// Avancer colIndex si cette position est "skippée"
					while (skipCells.has(`${rowIndex},${colIndex}`)) {
						colIndex++;
					}

					// Si cellule absente (Excel autorise les cellules vides non créées), on peut insérer une cellule vide
					const cell = cells[i];
					const data = cell.querySelector("Data");
					const text = data ? data.textContent : "";

					// Gestion styles
					const styleID = cell.getAttribute("ss:StyleID");
					const props = styleMap[styleID] || { classList: [], style: [] };
					const classAttr = props.classList.join(" ");
					const styleAttr = props.style.join("; ");

					// Gestion fusions
					const mergeAcross = cell.getAttribute("ss:MergeAcross");
					const colspan = mergeAcross ? parseInt(mergeAcross, 10) + 1 : 1;

					const mergeDown = cell.getAttribute("ss:MergeDown");
					const rowspan = mergeDown ? parseInt(mergeDown, 10) + 1 : 1;

					// Marquer les cellules à skipper dans les lignes suivantes pour fusion verticale
					if (rowspan > 1) {
						for (let r = rowIndex + 1; r < rowIndex + rowspan; r++) {
							for (let c = colIndex; c < colIndex + colspan; c++) {
								skipCells.add(`${r},${c}`);
							}
						}
					}

					html += `<td class="${classAttr}" style="${styleAttr}" colspan="${colspan}" rowspan="${rowspan}">${text}</td>`;

					colIndex += colspan;
				}

				// Gérer les cellules vides à la fin ? (optionnel)
				html += "</tr>";
			});

			html += "</tbody></table>";
  			return html;
		}
		function parseCsv(csvString) {
			return new Promise((resolve, reject) => {
				Papa.parse(csvString, {
					header: true,
					skipEmptyLines: true,
					complete: (results) => resolve(results.data),
					error: (err) => reject(err)
				});
			});
		}
		function jsonToTable(data) {
			if (!data.length) return '<p>Aucune donnée à afficher</p>';

			const cols = Object.keys(data[0]);
			let table = '<table><thead><tr>';

			cols.forEach(col => {
				table += `<th style="color: #FFFFFF; background-color: #808080">${col}</th>`;
			});
			table += '</tr></thead><tbody>';

			data.forEach(row => {
				table += '<tr>';
				cols.forEach(col => {
					table += `<td>${row[col] ?? ''}</td>`;
				});
				table += '</tr>';
			});

			table += '</tbody></table>';
			return table;
		}		
		async function updatePreview(content) {
			const pdfPreview = document.querySelector('#pdf-preview');
			const textPreview = document.querySelector('#text-preview');
			const excelPreview = document.querySelector('#excel-preview');
			pdfPreview.style.display = 'none';
			textPreview.style.display = 'none';
			excelPreview.style.display = 'none';
			if (isBase64PDF(content)) {
				pdfPreview.data = "data:application/pdf;base64," + content;
				pdfPreview.style.display = 'block';
			} else if (isBase64Excel(content)) {
				const htmlContent = excelToHTML(content);
				excelPreview.innerHTML = htmlContent;
				excelPreview.style.display = 'block';
			} else {
				const textContent = document.querySelector('#text-content');
				const decodedText = base64ToText(content);
				try {
					const data = await parseCsv(decodedText);
					excelPreview.innerHTML = jsonToTable(data);
					excelPreview.style.display = 'block';
				} catch (err) {
					console.log('Parsing CSV failed, showing as text:', err);
					textContent.textContent = decodedText;
					textPreview.style.display = 'block';
				}
			}
		}
		const base64Input = document.querySelector('#base64input');
		base64Input.addEventListener('paste', async (event) => {
			updatePreview((event.clipboardData || window.clipboardData).getData('text'));
		});
		base64Input.addEventListener('input', async (event) => {
			updatePreview(base64Input.value);
		});
		const run = document.querySelector('#run');
		run.addEventListener('click', async (event) => {
			updatePreview(base64Input.value);
		});
	</script>
</body>
</html>